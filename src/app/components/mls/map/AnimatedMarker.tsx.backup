"use client";

import { useEffect, useRef, useState } from "react";
import { motion } from "framer-motion";

interface AnimatedMarkerProps {
  price: string;
  propertyType?: string;
  mlsSource?: string;
  isSelected?: boolean;
  isHovered?: boolean;
  onClick?: () => void;
  onMouseEnter?: () => void;
  onMouseLeave?: () => void;
  isLight?: boolean;
}

function getMarkerTheme(
  propertyType?: string,
  mlsSource?: string,
  isLight?: boolean
) {
  const isRental = propertyType === "B";
  const isMultiFamily = propertyType === "C";
  const isCRMLS = mlsSource === "CRMLS";

  if (isRental) {
    // Purple/Violet for rentals
    return {
      primary: isCRMLS ? "#8b5cf6" : "#a855f7", // violet-500 / purple-500
      secondary: isCRMLS ? "#7c3aed" : "#9333ea", // violet-600 / purple-600
      glow: isCRMLS
        ? "rgba(139, 92, 246, 0.4)"
        : "rgba(168, 85, 247, 0.4)",
      text: "#ffffff"
    };
  }

  if (isMultiFamily) {
    // Yellow for multi-family
    return {
      primary: isCRMLS ? "#fde047" : "#eab308", // yellow-300 / yellow-500
      secondary: isCRMLS ? "#facc15" : "#ca8a04", // yellow-400 / yellow-600
      glow: "rgba(234, 179, 8, 0.4)",
      text: "#000000"
    };
  }

  // Sale properties - emerald/green
  if (isLight) {
    // Light mode: softer emerald tones
    return {
      primary: isCRMLS ? "#6ee7b7" : "#34d399", // emerald-300 / emerald-400
      secondary: isCRMLS ? "#10b981" : "#059669", // emerald-500 / emerald-600
      glow: "rgba(16, 185, 129, 0.3)",
      text: "#064e3b" // emerald-900
    };
  } else {
    // Dark mode: vibrant emerald
    return {
      primary: isCRMLS ? "#10b981" : "#059669", // emerald-500 / emerald-600
      secondary: isCRMLS ? "#059669" : "#047857", // emerald-600 / emerald-700
      glow: "rgba(16, 185, 129, 0.4)",
      text: "#ffffff"
    };
  }
}

export default function AnimatedMarker({
  price,
  propertyType,
  mlsSource,
  isSelected = false,
  isHovered = false,
  onClick,
  onMouseEnter,
  onMouseLeave,
  isLight = false
}: AnimatedMarkerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameRef = useRef<number>();
  const [mounted, setMounted] = useState(false);

  const theme = getMarkerTheme(propertyType, mlsSource, isLight);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    if (!mounted) return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // Dynamic sizing based on content
    const tempCtx = document.createElement("canvas").getContext("2d");
    if (!tempCtx) return;
    tempCtx.font = "600 12px Raleway, sans-serif";
    const textWidth = tempCtx.measureText(price).width;
    const width = Math.max(50, textWidth + 20);
    const height = 28;

    // Set canvas size with device pixel ratio
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    let shimmerPhase = 0;

    const animate = () => {
      if (!ctx) return;

      ctx.clearRect(0, 0, width, height);

      shimmerPhase += 0.03;

      const borderRadius = 6;

      // Outer glow effect
      if (isSelected || isHovered) {
        const glowSize = isSelected ? 8 : 4;
        const glowGradient = ctx.createRadialGradient(
          width / 2, height / 2, 0,
          width / 2, height / 2, Math.max(width, height) / 2 + glowSize
        );

        if (isSelected) {
          glowGradient.addColorStop(0, "rgba(6, 182, 212, 0.6)"); // cyan-500
          glowGradient.addColorStop(1, "rgba(6, 182, 212, 0)");
        } else {
          glowGradient.addColorStop(0, theme.glow);
          glowGradient.addColorStop(1, theme.glow.replace(/[\d.]+\)$/, "0)"));
        }

        ctx.fillStyle = glowGradient;
        ctx.fillRect(-glowSize, -glowSize, width + glowSize * 2, height + glowSize * 2);
      }

      // Background with gradient
      const bgGradient = ctx.createLinearGradient(0, 0, 0, height);

      if (isSelected) {
        // Cyan selection color
        bgGradient.addColorStop(0, "#06b6d4"); // cyan-500
        bgGradient.addColorStop(1, "#0891b2"); // cyan-600
      } else {
        bgGradient.addColorStop(0, theme.primary);
        bgGradient.addColorStop(1, theme.secondary);
      }

      // Draw rounded rectangle background
      ctx.fillStyle = bgGradient;
      ctx.beginPath();
      ctx.moveTo(borderRadius, 0);
      ctx.lineTo(width - borderRadius, 0);
      ctx.quadraticCurveTo(width, 0, width, borderRadius);
      ctx.lineTo(width, height - borderRadius);
      ctx.quadraticCurveTo(width, height, width - borderRadius, height);
      ctx.lineTo(borderRadius, height);
      ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
      ctx.lineTo(0, borderRadius);
      ctx.quadraticCurveTo(0, 0, borderRadius, 0);
      ctx.closePath();
      ctx.fill();

      // Shimmer effect
      const shimmerPos = ((shimmerPhase % (Math.PI * 2)) / (Math.PI * 2)) * (width + 40) - 20;
      const shimmerGradient = ctx.createLinearGradient(
        shimmerPos - 20, 0,
        shimmerPos + 20, 0
      );
      shimmerGradient.addColorStop(0, "rgba(255, 255, 255, 0)");
      shimmerGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.3)");
      shimmerGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

      ctx.save();
      ctx.fillStyle = shimmerGradient;
      ctx.beginPath();
      ctx.moveTo(borderRadius, 0);
      ctx.lineTo(width - borderRadius, 0);
      ctx.quadraticCurveTo(width, 0, width, borderRadius);
      ctx.lineTo(width, height - borderRadius);
      ctx.quadraticCurveTo(width, height, width - borderRadius, height);
      ctx.lineTo(borderRadius, height);
      ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
      ctx.lineTo(0, borderRadius);
      ctx.quadraticCurveTo(0, 0, borderRadius, 0);
      ctx.closePath();
      ctx.clip();
      ctx.fill();
      ctx.restore();

      // Border
      ctx.strokeStyle = isSelected
        ? "rgba(255, 255, 255, 0.9)"
        : isLight
          ? "rgba(0, 0, 0, 0.15)"
          : "rgba(0, 0, 0, 0.4)";
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.beginPath();
      ctx.moveTo(borderRadius, 0);
      ctx.lineTo(width - borderRadius, 0);
      ctx.quadraticCurveTo(width, 0, width, borderRadius);
      ctx.lineTo(width, height - borderRadius);
      ctx.quadraticCurveTo(width, height, width - borderRadius, height);
      ctx.lineTo(borderRadius, height);
      ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
      ctx.lineTo(0, borderRadius);
      ctx.quadraticCurveTo(0, 0, borderRadius, 0);
      ctx.closePath();
      ctx.stroke();

      // Glass highlight
      const highlightGradient = ctx.createLinearGradient(0, 0, 0, height / 2);
      highlightGradient.addColorStop(0, "rgba(255, 255, 255, 0.25)");
      highlightGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

      ctx.fillStyle = highlightGradient;
      ctx.beginPath();
      ctx.moveTo(borderRadius, 0);
      ctx.lineTo(width - borderRadius, 0);
      ctx.quadraticCurveTo(width, 0, width, borderRadius);
      ctx.lineTo(width, height / 2);
      ctx.lineTo(0, height / 2);
      ctx.lineTo(0, borderRadius);
      ctx.quadraticCurveTo(0, 0, borderRadius, 0);
      ctx.closePath();
      ctx.fill();

      animationFrameRef.current = requestAnimationFrame(animate);
    };

    animationFrameRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [price, isSelected, isHovered, theme, mounted, isLight]);

  if (!mounted) {
    return null;
  }

  return (
    <motion.div
      initial={{ scale: 0, y: -20, opacity: 0 }}
      animate={{
        scale: isSelected ? 1.25 : isHovered ? 1.1 : 1,
        y: 0,
        opacity: 1,
        zIndex: isSelected ? 100 : isHovered ? 40 : 30
      }}
      transition={{
        type: "spring",
        stiffness: 400,
        damping: 25
      }}
      whileHover={{ scale: isSelected ? 1.3 : 1.15 }}
      whileTap={{ scale: 0.95 }}
      onClick={onClick}
      onMouseEnter={onMouseEnter}
      onMouseLeave={onMouseLeave}
      className="cursor-pointer relative"
      style={{
        minWidth: 50,
        minHeight: 28,
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          filter: isSelected
            ? "drop-shadow(0 4px 12px rgba(6, 182, 212, 0.5))"
            : isHovered
              ? "drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3))"
              : "drop-shadow(0 1px 4px rgba(0, 0, 0, 0.2))"
        }}
      />
      <div
        className="absolute inset-0 flex items-center justify-center pointer-events-none px-2"
        style={{
          fontFamily: "Raleway, sans-serif",
          fontWeight: 600,
          fontSize: 12,
          color: isSelected ? "#000000" : theme.text,
          textShadow: isSelected
            ? "none"
            : theme.text === "#ffffff"
              ? "0 1px 2px rgba(0, 0, 0, 0.5)"
              : "0 1px 1px rgba(255, 255, 255, 0.3)",
          letterSpacing: "-0.01em"
        }}
      >
        {price}
      </div>
    </motion.div>
  );
}
