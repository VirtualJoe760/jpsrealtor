// src/app/components/mls/map/MapView.tsx
"use client";

import {
  useEffect,
  useState,
  useRef,
  useImperativeHandle,
  forwardRef,
} from "react";
import Map, { Marker, Source, Layer, ViewState, Popup } from "@vis.gl/react-maplibre";
import "maplibre-gl/dist/maplibre-gl.css";
import { MapListing } from "@/types/types";
import { MapMarker, isServerCluster } from "@/app/utils/map/useMapClusters";
import AnimatedCluster from "./AnimatedCluster";
import AnimatedMarker from "./AnimatedMarker";
import { useTheme } from "@/app/contexts/ThemeContext";
import HoverStatsOverlay from './HoverStatsOverlay';

export interface MapViewHandles {
  flyToCity: (lat: number, lng: number, zoom?: number) => void;
}

interface MapViewProps {
  listings: MapListing[]; // Deprecated - kept for backward compatibility
  markers?: MapMarker[]; // Server-side clusters or listings
  centerLat?: number;
  centerLng?: number;
  zoom?: number;
  onSelectListing: (listing: MapListing) => void;
  selectedListing?: MapListing | null;
  onBoundsChange?: (bounds: {
    north: number;
    south: number;
    east: number;
    west: number;
    zoom: number;
  }) => void;
  onSelectListingByIndex?: (index: number) => void;
  panelOpen?: boolean;
  mapStyle?: 'toner' | 'dark' | 'satellite' | 'bright';
}

// MapTiler API Key
const MAPTILER_KEY = process.env.NEXT_PUBLIC_MAPTILER_API_KEY || "";

// Map style URLs - 4 different map styles
const MAP_STYLES = {
  toner: MAPTILER_KEY && MAPTILER_KEY !== "get_your_maptiler_key_here"
    ? `https://api.maptiler.com/maps/toner-v2/style.json?key=${MAPTILER_KEY}`
    : "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
  dark: "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json",
  satellite: MAPTILER_KEY && MAPTILER_KEY !== "get_your_maptiler_key_here"
    ? `https://api.maptiler.com/maps/satellite/style.json?key=${MAPTILER_KEY}`
    : "https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json",
  bright: MAPTILER_KEY && MAPTILER_KEY !== "get_your_maptiler_key_here"
    ? `https://api.maptiler.com/maps/bright/style.json?key=${MAPTILER_KEY}`
    : "https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json",
};

function formatPrice(price?: number): string {
  if (!price) return "‚Äî";
  if (price >= 1_000_000) return `$${(price / 1_000_000).toFixed(1)}m`;
  if (price >= 1_000) return `$${(price / 1_000).toFixed(0)}k`;
  return `$${price}`;
}

const MapView = forwardRef<MapViewHandles, MapViewProps>(function MapView(
  {
    listings,
    markers,
    centerLat,
    centerLng,
    zoom,
    onSelectListing,
    selectedListing,
    onBoundsChange,
    onSelectListingByIndex,
    panelOpen = false,
    mapStyle = 'toner',
  },
  ref
) {
  const { currentTheme } = useTheme();
  const isLight = currentTheme === "lightgradient";

  const [hoveredId, setHoveredId] = useState<string | null>(null);
  const [internalSelected, setInternalSelected] = useState<MapListing | null>(selectedListing ?? null);
  const [hoveredPolygon, setHoveredPolygon] = useState<{
    name: string;
    count: number;
    avgPrice: number;
    minPrice: number;
    maxPrice: number;
    type: 'county' | 'city' | 'region';
  } | null>(null);

  const mapRef = useRef<any>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const debounceRef = useRef<NodeJS.Timeout | null>(null);
  const panelOpenRef = useRef<boolean>(panelOpen);
  const lastBoundsKeyRef = useRef<string | null>(null);

  // Update panel ref when it changes
  useEffect(() => {
    panelOpenRef.current = panelOpen;
  }, [panelOpen]);

  // Sync internal selection with prop
  useEffect(() => {
    if (selectedListing) {
      setInternalSelected((prev) =>
        prev?._id === selectedListing._id ? prev : selectedListing
      );
    } else {
      setInternalSelected(null);
    }
  }, [selectedListing]);

  // Initial view state
  const hydratedInitialViewState: ViewState = {
    latitude: centerLat ?? 33.72,
    longitude: centerLng ?? -116.37,
    zoom: zoom ?? 11,
    bearing: 0,
    pitch: 0,
    padding: { top: 0, bottom: 0, left: 0, right: 0 },
  };

  // Update map style dynamically
  useEffect(() => {
    const map = mapRef.current?.getMap?.();
    if (!map || !map.isStyleLoaded()) return;

    const newStyleURL = MAP_STYLES[mapStyle];
    const currentStyleSpec = map.getStyle();
    if (!currentStyleSpec) return;

    const needsUpdate = !currentStyleSpec.name ||
                       (mapStyle === 'dark' && !currentStyleSpec.name.includes('dark')) ||
                       (mapStyle === 'bright' && !currentStyleSpec.name.includes('voyager') && !currentStyleSpec.name.includes('bright')) ||
                       (mapStyle === 'satellite' && !currentStyleSpec.name.includes('satellite')) ||
                       (mapStyle === 'toner' && !currentStyleSpec.name.includes('positron') && !currentStyleSpec.name.includes('toner'));

    if (needsUpdate) {
      map.setStyle(newStyleURL);
    }
  }, [mapStyle]);

  // Enable/disable map gestures when panel is open
  useEffect(() => {
    const map = mapRef.current?.getMap?.();
    if (!map) return;

    const handlers = [
      map.dragPan,
      map.dragRotate,
      map.scrollZoom,
      map.boxZoom,
      map.keyboard,
      map.doubleClickZoom,
      map.touchZoomRotate,
    ].filter(Boolean);

    if (panelOpen) {
      handlers.forEach((h: any) => h.disable());
    } else {
      handlers.forEach((h: any) => h.enable());
    }
  }, [panelOpen]);

  // Cleanup debounce on unmount
  useEffect(() => {
    return () => {
      if (debounceRef.current) clearTimeout(debounceRef.current);
    };
  }, []);

  // Update clusters when map moves/zooms
  const updateClusters = () => {
    if (panelOpenRef.current) {
      console.log('‚è∏Ô∏è updateClusters: Panel open, skipping');
      return;
    }

    const map = mapRef.current?.getMap?.();
    if (!map) {
      console.log('‚è∏Ô∏è updateClusters: Map not ready');
      return;
    }

    const bounds = map.getBounds();
    const zoomVal = map.getZoom();

    console.log('üîÑ updateClusters called - Zoom:', Math.floor(zoomVal));

    const key = `${bounds.getNorth().toFixed(6)}-${bounds.getSouth().toFixed(6)}-${bounds.getEast().toFixed(6)}-${bounds.getWest().toFixed(6)}-${zoomVal.toFixed(2)}`;

    if (key === lastBoundsKeyRef.current) {
      console.log('‚è≠Ô∏è updateClusters: Same bounds, skipping');
      return;
    }

    if (debounceRef.current) clearTimeout(debounceRef.current);

    debounceRef.current = setTimeout(() => {
      if (panelOpenRef.current) return;

      lastBoundsKeyRef.current = key;

      console.log('‚úÖ updateClusters: Notifying parent of bounds change');
      console.log('üìç Bounds:', {
        north: bounds.getNorth().toFixed(4),
        south: bounds.getSouth().toFixed(4),
        east: bounds.getEast().toFixed(4),
        west: bounds.getWest().toFixed(4),
        zoom: Math.floor(zoomVal)
      });

      onBoundsChange?.({
        north: bounds.getNorth(),
        south: bounds.getSouth(),
        east: bounds.getEast(),
        west: bounds.getWest(),
        zoom: Math.floor(zoomVal),
      });
    }, 250);
  };

  // Handle map events
  const handleMoveEnd = () => {
    console.log('üöÄ handleMoveEnd called');
    if (panelOpen) {
      console.log('‚è∏Ô∏è handleMoveEnd: Panel open, ignoring');
      return;
    }
    updateClusters();
  };

  const handleDragEnd = () => {
    console.log('üöÄ handleDragEnd called');
    if (panelOpen) {
      console.log('‚è∏Ô∏è handleDragEnd: Panel open, ignoring');
      return;
    }
    updateClusters();
  };

  // Setup map event listeners
  useEffect(() => {
    const map = mapRef.current?.getMap?.();
    if (!map) return;

    console.log('üéØ Setting up map event listeners');

    const onLoad = () => {
      console.log('üó∫Ô∏è Map loaded');
      updateClusters();

      // Set default cursor to pointer instead of grab/grabbing
      map.getCanvas().style.cursor = 'pointer';

      // Add click handlers for region polygons
      const regionData = dataToRender.filter((m: any) => m.clusterType === 'region' && m.polygon);

      regionData.forEach((marker: any) => {
        const regionName = marker.regionName;
        const layerId = `region-fill-${regionName}`;

        // Add click handler
        map.on('click', layerId, () => {
          console.log(`üéØ Region clicked: ${regionName}`);

          // Calculate bounds from polygon coordinates
          const coords = marker.polygon;
          let minLng = Infinity, maxLng = -Infinity;
          let minLat = Infinity, maxLat = -Infinity;

          // Handle both Polygon and MultiPolygon formats
          const flattenCoords = (coordArray: any[]): void => {
            coordArray.forEach((item: any) => {
              if (Array.isArray(item) && typeof item[0] === 'number') {
                // This is a coordinate pair [lng, lat]
                const [lng, lat] = item;
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
              } else if (Array.isArray(item)) {
                // Recurse into nested arrays
                flattenCoords(item);
              }
            });
          };

          flattenCoords(coords);

          // Fit map to region bounds
          map.fitBounds(
            [[minLng, minLat], [maxLng, maxLat]],
            {
              padding: 50,
              duration: 1000,
              maxZoom: 8
            }
          );
        });

        // Change cursor to pointer on hover and show label
        map.on('mouseenter', layerId, (e: any) => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Set hover state for 3D effect
          if (e.features && e.features[0]) {
            map.setFeatureState(
              { source: `region-source-${regionName}`, id: e.features[0].id },
              { hover: true }
            );
          }
          
          // Store hovered area data
          setHoveredPolygon({
            name: marker.regionName,
            count: marker.count,
            avgPrice: marker.avgPrice,
            minPrice: marker.minPrice,
            maxPrice: marker.maxPrice,
            type: 'region'
          });
        });

        map.on('mouseleave', layerId, () => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Remove hover state
          if (map.getSource(`region-source-${regionName}`)) {
            map.removeFeatureState({ source: `region-source-${regionName}` });
          }
          
          setHoveredPolygon(null);
        });
      });

      // Add click handlers for county polygons
      const countyData = dataToRender.filter((m: any) => m.clusterType === 'county' && m.polygon);

      countyData.forEach((marker: any) => {
        const countyName = marker.countyName;
        const layerId = `county-fill-${countyName}`;

        // Add click handler
        map.on('click', layerId, () => {
          console.log(`üéØ County clicked: ${countyName}`);

          // Calculate bounds from polygon coordinates
          const coords = marker.polygon;
          let minLng = Infinity, maxLng = -Infinity;
          let minLat = Infinity, maxLat = -Infinity;

          // Handle both Polygon and MultiPolygon formats
          const flattenCoords = (coordArray: any[]): void => {
            coordArray.forEach((item: any) => {
              if (Array.isArray(item) && typeof item[0] === 'number') {
                // This is a coordinate pair [lng, lat]
                const [lng, lat] = item;
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
              } else if (Array.isArray(item)) {
                // Recurse into nested arrays
                flattenCoords(item);
              }
            });
          };

          flattenCoords(coords);

          // Fit map to county bounds
          map.fitBounds(
            [[minLng, minLat], [maxLng, maxLat]],
            {
              padding: 50,
              duration: 1000,
              maxZoom: 11
            }
          );
        });

        // Change cursor to pointer on hover and show label
        map.on('mouseenter', layerId, (e: any) => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Set hover state for 3D effect
          if (e.features && e.features[0]) {
            map.setFeatureState(
              { source: `county-source-${countyName}`, id: e.features[0].id },
              { hover: true }
            );
          }
          
          // Store hovered area data
          setHoveredPolygon({
            name: marker.countyName,
            count: marker.count,
            avgPrice: marker.avgPrice,
            minPrice: marker.minPrice,
            maxPrice: marker.maxPrice,
            type: 'county'
          });
        });

        map.on('mouseleave', layerId, () => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Remove hover state
          if (map.getSource(`county-source-${countyName}`)) {
            map.removeFeatureState({ source: `county-source-${countyName}` });
          }
          
          setHoveredPolygon(null);
        });
      });


      // Set up city polygon click handlers (zoom 9-10)
      const cityData = dataToRender.filter((m: any) => m.clusterType === 'city' && m.polygon);

      cityData.forEach((marker: any) => {
        const cityName = marker.cityName;
        const layerId = `city-fill-${cityName}`;

        // Add click handler
        map.on('click', layerId, () => {
          console.log(`üéØ City clicked: ${cityName}`);

          // Calculate bounds from polygon coordinates
          const coords = marker.polygon;
          let minLng = Infinity, maxLng = -Infinity;
          let minLat = Infinity, maxLat = -Infinity;

          // Handle both Polygon and MultiPolygon formats
          const flattenCoords = (coordArray: any[]): void => {
            coordArray.forEach((item: any) => {
              if (Array.isArray(item) && typeof item[0] === 'number') {
                // This is a coordinate pair [lng, lat]
                const [lng, lat] = item;
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
              } else if (Array.isArray(item)) {
                // Recurse into nested arrays
                flattenCoords(item);
              }
            });
          };

          flattenCoords(coords);

          // Fit map to city bounds
          map.fitBounds(
            [[minLng, minLat], [maxLng, maxLat]],
            {
              padding: 50,
              duration: 1000,
              maxZoom: 13
            }
          );
        });

        // Change cursor to pointer on hover and show label
        map.on('mouseenter', layerId, (e: any) => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Set hover state for 3D effect
          if (e.features && e.features[0]) {
            map.setFeatureState(
              { source: `city-source-${cityName}`, id: e.features[0].id },
              { hover: true }
            );
          }
          
          // Store hovered area data
          setHoveredPolygon({
            name: marker.cityName,
            count: marker.count,
            avgPrice: marker.avgPrice,
            minPrice: marker.minPrice,
            maxPrice: marker.maxPrice,
            type: 'city'
          });
        });

        map.on('mouseleave', layerId, () => {
          map.getCanvas().style.cursor = 'pointer';
          
          // Remove hover state
          if (map.getSource(`city-source-${cityName}`)) {
            map.removeFeatureState({ source: `city-source-${cityName}` });
          }
          
          setHoveredPolygon(null);
        });
      });
    };

    if (map.isStyleLoaded()) {
      onLoad();
    } else {
      map.once("load", onLoad);
    }

    const onZoomEnd = () => {
      console.log('üîç Zoom ended');
      updateClusters();
    };

    map.on("zoomend", onZoomEnd);

    return () => {
      try {
        map.off("zoomend", onZoomEnd);

        // Clean up region click handlers
        const regionNames = ['Northern California', 'Central California', 'Southern California'];
        regionNames.forEach(regionName => {
          const layerId = `region-fill-${regionName}`;
          map.off('click', layerId);
          map.off('mouseenter', layerId);
          map.off('mouseleave', layerId);
        });

        // Clean up county click handlers
        const countyData = dataToRender.filter((m: any) => m.clusterType === 'county' && m.polygon);
        countyData.forEach((marker: any) => {
          const layerId = `county-fill-${marker.countyName}`;
          map.off('click', layerId);
          map.off('mouseenter', layerId);
          map.off('mouseleave', layerId);
        });

        // Clean up city click handlers
        const cityData = dataToRender.filter((m: any) => m.clusterType === 'city' && m.polygon);
        cityData.forEach((marker: any) => {
          const layerId = `city-fill-${marker.cityName}`;
          map.off('click', layerId);
          map.off('mouseenter', layerId);
          map.off('mouseleave', layerId);
        });
      } catch {}
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Handle marker clicks
  const handleMarkerClick = (listing: MapListing) => {
    setHoveredId(null);
    setInternalSelected(listing);
    onSelectListing(listing);

    if (onSelectListingByIndex) {
      const index = listings.findIndex((l) => l._id === listing._id);
      onSelectListingByIndex(index >= 0 ? index : 0);
    }
  };

  // Handle cluster clicks
  const handleClusterClick = (clusterLat: number, clusterLng: number) => {
    if (panelOpen) return;

    const map = mapRef.current?.getMap?.();
    if (!map) return;

    console.log('üéØ Cluster clicked - zooming in');
    map.flyTo({
      center: [clusterLng, clusterLat],
      zoom: Math.min(map.getZoom() + 2, 18),
      duration: 1000
    });
  };

  // Expose flyToCity method
  useImperativeHandle(ref, () => ({
    flyToCity(lat: number, lng: number, zoomLevel = 12) {
      console.log('üöÅ flyToCity called - lat:', lat, 'lng:', lng, 'zoom:', zoomLevel);
      const map = mapRef.current?.getMap?.();
      if (!map) {
        console.error('‚ùå flyToCity: map ref not available');
        return;
      }
      map.easeTo({
        center: [lng, lat],
        zoom: zoomLevel,
        duration: 1000,
        offset: [0, -250],
      });
    },
  }));

  // Check if listing is selected
  const isSelected = (l: MapListing) => {
    const id = l._id;
    if (!id) return false;
    const matchesSelected = selectedListing && selectedListing._id === id;
    const matchesInternal = internalSelected && internalSelected._id === id;
    return !!(matchesSelected || matchesInternal);
  };

  const currentMapStyleURL = MAP_STYLES[mapStyle];

  // Use markers if provided, otherwise fall back to listings
  const dataToRender = (markers && markers.length > 0) ? markers : listings;

  console.log('üó∫Ô∏è MapView render:', {
    markersCount: markers?.length ?? 0,
    listingsCount: listings.length,
    dataToRenderCount: dataToRender.length,
    mapStyle,
    panelOpen
  });

  return (
    <div ref={wrapperRef} className="relative w-full h-full">
      <Map
        ref={mapRef}
        mapStyle={currentMapStyleURL}
        key={`map-${mapStyle}`}
        initialViewState={hydratedInitialViewState}
        onMoveEnd={handleMoveEnd}
        onDragEnd={handleDragEnd}
        interactive={!panelOpen}
      >
        {/* Hover Stats Overlay */}
        <HoverStatsOverlay data={hoveredPolygon} />

        {/* Render region polygon overlays for zoom <= 6 */}
        {dataToRender && dataToRender.length > 0 && dataToRender.some((m: any) => m.clusterType === 'region' && m.polygon) && (
          <>
            {dataToRender
              .filter((m: any) => m.clusterType === 'region' && m.polygon)
              .map((marker: any, i: number) => {
                const regionColor =
                  marker.regionName === 'Northern California' ? '#3b82f6' : // Blue
                  marker.regionName === 'Central California' ? '#10b981' : // Emerald
                  '#f59e0b'; // Amber for Southern California

                // Determine geometry type from polygon structure
                // If polygon is array of arrays (MultiPolygon format), use MultiPolygon
                // If polygon is single array (Polygon format), use Polygon
                const isMultiPolygon = Array.isArray(marker.polygon[0]) &&
                                      Array.isArray(marker.polygon[0][0]) &&
                                      Array.isArray(marker.polygon[0][0][0]);

                const geometryType = isMultiPolygon ? 'MultiPolygon' : 'Polygon';

                return (
                  <Source
                    key={`region-source-${marker.regionName}`}
                    id={`region-source-${marker.regionName}`}
                    type="geojson"
                    data={{
                      type: 'Feature',
                      id: 0, // Required for feature-state to work
                      geometry: {
                        type: geometryType,
                        coordinates: marker.polygon
                      },
                      properties: {
                        name: marker.regionName,
                        count: marker.count
                      }
                    }}
                  >
                    {/* SHADOW/GLOW LAYER - Creates dramatic glow effect on hover */}
                    <Layer
                      id={`region-shadow-${marker.regionName}`}
                      type="line"
                      paint={{
                        'line-color': isLight ? '#8b5cf6' : '#a78bfa',
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          12,
                          0
                        ],
                        'line-blur': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          8,
                          0
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.6,
                          0
                        ]
                      }}
                    />
                    <Layer
                      id={`region-fill-${marker.regionName}`}
                      type="fill"
                      paint={{
                        'fill-color': regionColor,
                        'fill-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.55,  // hover - more dramatic
                          0.35   // base - more visible
                        ]
                      }}
                    />
                    <Layer
                      id={`region-outline-${marker.regionName}`}
                      type="line"
                      paint={{
                        'line-color': regionColor,
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          4,
                          2
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          1.0,
                          0.7
                        ]
                      }}
                    />
                    {/* Region labels temporarily disabled */}
                    {/*                     <Layer
                      id={`region-label-${marker.regionName}`}
                      type="symbol"
                      layout={{
                        'text-field': marker.regionName,
                        'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                        'text-size': 24,
                        'text-transform': 'uppercase',
                        'text-letter-spacing': 0.1,
                        'text-max-width': 8,
                        'symbol-placement': 'point',
                        'text-allow-overlap': false,
                        'text-ignore-placement': false
                      }}
                      paint={{
                        'text-color': isLight ? '#1f2937' : '#ffffff',
                        'text-halo-color': isLight ? '#ffffff' : '#000000',
                        'text-halo-width': 3,
                        'text-halo-blur': 2
                      }}
                    />
                    */}
                  </Source>
                );
              })}
          </>
        )}

        {/* Render county polygon overlays for zoom 7-8 */}
        {dataToRender && dataToRender.length > 0 && dataToRender.some((m: any) => m.clusterType === 'county' && m.polygon) && (
          <>
            {dataToRender
              .filter((m: any) => m.clusterType === 'county' && m.polygon)
              .map((marker: any, i: number) => {
                const countyColor = isLight ? '#6366f1' : '#8b5cf6';
                const isMultiPolygon = Array.isArray(marker.polygon[0]) &&
                                      Array.isArray(marker.polygon[0][0]) &&
                                      Array.isArray(marker.polygon[0][0][0]);
                const geometryType = isMultiPolygon ? 'MultiPolygon' : 'Polygon';

                return (
                  <Source
                    key={`county-source-${marker.countyName}`}
                    id={`county-source-${marker.countyName}`}
                    type="geojson"
                    data={{
                      type: 'Feature',
                      id: 0, // Required for feature-state to work
                      geometry: {
                        type: geometryType,
                        coordinates: marker.polygon
                      },
                      properties: {
                        name: marker.countyName,
                        count: marker.count
                      }
                    }}
                  >
                    {/* SHADOW/GLOW LAYER - Creates dramatic glow effect on hover */}
                    <Layer
                      id={`county-shadow-${marker.countyName}`}
                      type="line"
                      paint={{
                        'line-color': isLight ? '#4f46e5' : '#818cf8',
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          12,
                          0
                        ],
                        'line-blur': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          8,
                          0
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.6,
                          0
                        ]
                      }}
                    />
                    <Layer
                      id={`county-fill-${marker.countyName}`}
                      type="fill"
                      paint={{
                        'fill-color': isLight ? '#4f46e5' : '#6366f1',
                        'fill-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.55,  // hover - more dramatic
                          0.35   // base - more visible
                        ]
                      }}
                    />
                    <Layer
                      id={`county-outline-${marker.countyName}`}
                      type="line"
                      paint={{
                        'line-color': isLight ? '#4338ca' : '#a5b4fc',
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          4,
                          2
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          1.0,
                          0.7
                        ]
                      }}
                    />
                    {/* County labels temporarily disabled */}
                    {/* <Layer
                      id={`county-label-${marker.countyName}`}
                      type="symbol"
                      layout={{
                        'text-field': marker.countyName,
                        'text-font': ['Open Sans Semibold', 'Arial Unicode MS Regular'],
                        'text-size': 16,
                        'text-transform': 'uppercase',
                        'text-letter-spacing': 0.05,
                        'text-max-width': 10,
                        'symbol-placement': 'point',
                        'symbol-spacing': 1000,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-optional': true
                      }}
                      paint={{
                        'text-color': isLight ? '#4338ca' : '#a78bfa',
                        'text-halo-color': isLight ? '#ffffff' : '#000000',
                        'text-halo-width': 2,
                        'text-halo-blur': 1
                      }}
                    /> */}
                  </Source>
                );
              })}
          </>
        )}


        {/* Render city polygon overlays for zoom 9-10 */}
        {dataToRender && dataToRender.length > 0 && dataToRender.some((m: any) => m.clusterType === 'city' && m.polygon) && (
          <>
            {dataToRender
              .filter((m: any) => m.clusterType === 'city' && m.polygon)
              .map((marker: any, i: number) => {
                const cityColor = isLight ? '#10b981' : '#34d399';
                const isMultiPolygon = Array.isArray(marker.polygon[0]) &&
                                      Array.isArray(marker.polygon[0][0]) &&
                                      Array.isArray(marker.polygon[0][0][0]);
                const geometryType = isMultiPolygon ? 'MultiPolygon' : 'Polygon';

                return (
                  <Source
                    key={`city-source-${marker.cityName}`}
                    id={`city-source-${marker.cityName}`}
                    type="geojson"
                    data={{
                      type: 'Feature',
                      id: 0, // Required for feature-state to work
                      geometry: {
                        type: geometryType,
                        coordinates: marker.polygon
                      },
                      properties: {
                        name: marker.cityName,
                        count: marker.count
                      }
                    }}
                  >
                    {/* SHADOW/GLOW LAYER - Creates dramatic glow effect on hover */}
                    <Layer
                      id={`city-shadow-${marker.cityName}`}
                      type="line"
                      paint={{
                        'line-color': isLight ? '#10b981' : '#6ee7b7',
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          12,
                          0
                        ],
                        'line-blur': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          8,
                          0
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.6,
                          0
                        ]
                      }}
                    />
                    <Layer
                      id={`city-fill-${marker.cityName}`}
                      type="fill"
                      paint={{
                        'fill-color': isLight ? '#10b981' : '#34d399',
                        'fill-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          0.55,  // hover - more dramatic
                          0.35   // base - more visible
                        ]
                      }}
                    />
                    <Layer
                      id={`city-outline-${marker.cityName}`}
                      type="line"
                      paint={{
                        'line-color': isLight ? '#059669' : '#6ee7b7',
                        'line-width': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          4,
                          2
                        ],
                        'line-opacity': ['case',
                          ['boolean', ['feature-state', 'hover'], false],
                          1.0,
                          0.7
                        ]
                      }}
                    />
                  </Source>
                );
              })}
          </>
        )}
        {/* Render all markers */}
        {dataToRender && dataToRender.length > 0 ? (
          dataToRender.map((marker, i) => {
            if (isServerCluster(marker)) {
              // Skip rendering markers for region, county, and city clusters (they have polygon overlays instead)
              if ((marker as any).clusterType === 'region' || (marker as any).clusterType === 'county' || (marker as any).clusterType === 'city') {
                return null;
              }

              // Render server-side cluster
              const size = Math.min(40 + marker.count * 0.01, 80);
              console.log(`üé® Rendering cluster #${i}:`, {
                lat: marker.latitude,
                lng: marker.longitude,
                count: marker.count,
                size,
                isCluster: marker.isCluster
              });
              return (
                <Marker
                  key={`cluster-${marker.latitude}-${marker.longitude}-${i}`}
                  longitude={marker.longitude}
                  latitude={marker.latitude}
                  anchor="center"
                  onClick={() => handleClusterClick(marker.latitude, marker.longitude)}
                >
                  <AnimatedCluster
                    count={marker.count}
                    size={size}
                    onClick={() => {}}
                    isLight={isLight}
                    regionName={(marker as any).regionName}
                    cityName={(marker as any).cityName}
                    subdivisionName={(marker as any).subdivisionName}
                    countyName={(marker as any).countyName}
                    photoUrl={(marker as any).photoUrl}
                    clusterType={(marker as any).clusterType || 'city'}
                  />
                </Marker>
              );
            } else {
              // Render individual listing
              const listing = marker as MapListing;
              if (!listing.longitude || !listing.latitude || !listing._id) return null;

              const selected = isSelected(listing);
              const hovered = hoveredId === listing._id;
              const showSelected = selected && !panelOpen;

              return (
                <Marker
                  key={listing._id || `marker-${i}`}
                  longitude={listing.longitude}
                  latitude={listing.latitude}
                  anchor="bottom"
                  onClick={() => handleMarkerClick(listing)}
                >
                  <AnimatedMarker
                    price={formatPrice(listing.listPrice)}
                    propertyType={listing.propertyType}
                    mlsSource={listing.mlsSource}
                    isSelected={showSelected}
                    isHovered={hovered}
                    onMouseEnter={() => setHoveredId(listing._id)}
                    onMouseLeave={() => setHoveredId(null)}
                    isLight={isLight}
                  />
                </Marker>
              );
            }
          })
        ) : null}

        {/* Hover tooltip for polygons */}
        {hoveredPolygon && (
          <Popup
            longitude={hoveredPolygon.lng}
            latitude={hoveredPolygon.lat}
            closeButton={false}
            closeOnClick={false}
            anchor="bottom"
            offset={10}
            className="polygon-hover-popup"
          >
            <div
              className={`px-3 py-2 rounded-lg font-bold text-sm ${
                isLight
                  ? 'bg-white text-gray-900 shadow-lg'
                  : 'bg-gray-900 text-white shadow-xl'
              }`}
              style={{
                border: isLight ? '2px solid #3b82f6' : '2px solid #8b5cf6',
              }}
            >
              {hoveredPolygon.name}
            </div>
          </Popup>
        )}
      </Map>
    </div>
  );
});

export default MapView;
