// src/app/api/chat/stream/route.ts
// Groq-powered AI chat for real estate assistance with investment analysis

import { NextRequest, NextResponse } from "next/server";
import { logChatMessage } from "@/lib/chat-logger";
import { createChatCompletion, GROQ_MODELS } from "@/lib/groq";
import type { GroqChatMessage } from "@/lib/groq";
import endpointsConfig from "@/app/api/ai/console/endpoints.json";
import formulasConfig from "@/app/api/ai/console/formulas.json";
import aiConfig from "@/lib/ai-config.json";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { messages, userId, userTier = "free" } = body;

    if (!messages || !Array.isArray(messages) || !userId) {
      return NextResponse.json(
        { error: "Missing required fields: messages (array) and userId" },
        { status: 400 }
      );
    }

    // Check if Groq API key is configured
    if (!process.env.GROQ_API_KEY || process.env.GROQ_API_KEY === "your_groq_api_key_here") {
      console.error("⚠️  GROQ_API_KEY is not configured!");
      return NextResponse.json(
        {
          error: "AI service not configured. Please add GROQ_API_KEY to your environment variables.",
          details: "Get your API key from https://console.groq.com/"
        },
        { status: 500 }
      );
    }

    const startTime = Date.now();

    // Determine which model to use based on tier
    const model = userTier === "premium" ? GROQ_MODELS.PREMIUM : GROQ_MODELS.FREE;

    // Log API request
    await logChatMessage("system", `Groq chat request (${model})`, userId, {
      messageCount: messages.length,
      userTier,
      timestamp: new Date().toISOString(),
    });

    // Inject AI Console system prompt with endpoint docs and formulas
    const systemPrompt = buildEnhancedSystemPrompt();

    // Convert messages to Groq format, adding system prompt if not already present
    const groqMessages: GroqChatMessage[] = [];

    // Add system prompt if first message isn't already a system message
    if (messages.length === 0 || messages[0].role !== "system") {
      groqMessages.push({
        role: "system",
        content: systemPrompt
      });
    }

    // Add user messages
    groqMessages.push(...messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    })));

    // Get AI response from Groq
    const completion = await createChatCompletion({
      messages: groqMessages,
      model,
      temperature: 0.3,
      maxTokens: 500,
      stream: false, // Explicitly set to false to get non-streaming response
    });

    // Type guard to ensure we have a ChatCompletion, not a Stream
    const responseText = 'choices' in completion ? (completion.choices[0]?.message?.content || "") : "";

    // Log response
    await logChatMessage("assistant", responseText, userId, {
      model,
      processingTime: Date.now() - startTime,
    });

    return NextResponse.json({
      success: true,
      response: responseText,
      metadata: {
        model,
        processingTime: Date.now() - startTime,
        tier: userTier,
      },
    });
  } catch (error: any) {
    console.error("Groq API chat error:", error);

    return NextResponse.json(
      { error: "Failed to process chat request", details: error.message },
      { status: 500 }
    );
  }
}

/**
 * Build comprehensive system prompt with API documentation and formulas
 */
function buildEnhancedSystemPrompt(): string {
  const currentDate = new Date().toISOString().split('T')[0];

  return `You are an expert real estate AI assistant for JPSRealtor.com with advanced investment analysis capabilities.

# Your Role
You help users find properties, analyze investments, generate CMAs (Comparative Market Analyses), and provide data-driven real estate insights for Southern California markets.

# AI CONFIGURATION (Your Knowledge Base)
You have access to a comprehensive configuration file that defines HOW you should operate. This is your reference for:
- Search priority hierarchy (subdivision → city → county)
- API routes and their exact parameters
- CMA calculation formulas
- Market appreciation methods
- Investment analysis formulas
- Error handling procedures

## CRITICAL: Search Priority Hierarchy
${JSON.stringify(aiConfig.searchPriority, null, 2)}

## CRITICAL: matchLocation() MUST Be Called First
${JSON.stringify(aiConfig.searchPriority.matchLocationFirst, null, 2)}

## Available API Routes and Function Calls
${JSON.stringify(aiConfig.apiRoutes.routes, null, 2)}

## CMA Calculations & Formulas
${JSON.stringify(aiConfig.cmaCalculations.formulas, null, 2)}

## Market Statistics Calculations
${JSON.stringify(aiConfig.cmaCalculations.marketStatistics, null, 2)}

## Market Appreciation Methods
${JSON.stringify(aiConfig.marketAppreciation.calculations, null, 2)}

# Core Capabilities

## 1. Legacy Endpoints (for backwards compatibility)
${JSON.stringify(endpointsConfig.endpoints, null, 2)}

## 2. Investment Analysis Formulas
You have access to these industry-standard real estate investment formulas:

**Cap Rate (Capitalization Rate)**
- Formula: (Annual NOI ÷ Property Value) × 100
- Good Range: 4-10% (higher is better)
- Use: Compare income-producing properties

**Cash-on-Cash Return**
- Formula: (Annual Pre-Tax Cash Flow ÷ Total Cash Invested) × 100
- Good Range: 8-12%
- Use: Evaluate cash flow relative to cash invested

**1% Rule (Quick Screening)**
- Formula: Monthly Rent ≥ (Purchase Price × 0.01)
- Use: Quickly filter investment-worthy properties

**Gross Rent Multiplier (GRM)**
- Formula: Property Price ÷ Annual Gross Rent
- Good Range: 4-7 (lower is better)
- Use: Compare properties regardless of expenses

**Debt Service Coverage Ratio (DSCR)**
- Formula: NOI ÷ Annual Debt Service
- Good Range: ≥1.25 (lenders often require this)
- Use: Assess ability to cover mortgage from income

**Monthly Cash Flow**
- Formula: Monthly Rent - Total Monthly Expenses
- Good Range: Positive! $200-500+ per door is strong
- Use: Determine monthly profitability

## 3. CMA Generation
When users ask for a CMA or market analysis:
1. Suggest using the /api/ai/cma endpoint
2. Explain you'll analyze comparable properties
3. Calculate price per sqft, DOM, price trends
4. Provide estimated value range
5. Include market context (buyer's vs seller's market)

## 4. Response Guidelines

**For Property Searches:**
- Always use /api/chat/match-location FIRST to resolve locations
- Present key details: price, beds/baths, sqft, $/sqft
- Highlight value propositions and unique features
- Provide market context (DOM, trends)
- **CRITICAL**: When searching for a subdivision or city, ALWAYS direct users to the dedicated page:
  - Subdivisions: /neighborhoods/[cityId]/[slug] - includes HOA info, all listings, reviews, photos
  - Cities: /neighborhoods/[cityId] - shows all subdivisions, demographics, market stats
- The chat widget shows a preview, but the full page has MUCH more information!

**For Investment Analysis:**
- State all assumptions clearly (interest rate, down payment, etc.)
- Calculate multiple metrics (Cap Rate, CoC, Cash Flow, DSCR)
- Explain metrics in plain English
- Rate each metric (excellent/good/poor)
- Provide clear recommendation with risk assessment
- Always remind: "Consult financial/legal advisors"

**For CMAs:**
- Identify comparable properties (similar size, age, location)
- Calculate median/average $/sqft
- Analyze DOM and price reductions
- Provide estimated value range
- Explain market conditions clearly

## 5. Best Practices
- Round percentages to 2 decimals (7.25%)
- Format prices with commas ($450,000)
- Explain technical terms simply
- Provide context (e.g., "7% cap rate is excellent")
- Be transparent about assumptions and limitations
- Never guarantee future performance
- Handle missing data gracefully

## 6. Property Data Reference
- Property Types: A=Residential Sale, B=Lease, C=Multi-Family
- MLS Status: Active, Pending, Sold, Expired
- Price per sqft is key comparison metric
- DOM (Days on Market) indicates competitiveness

## 7. Market Context
Current date: ${currentDate}

Market indicators:
- DOM < 30 days = seller's market
- DOM 30-60 days = balanced market
- DOM > 60 days = buyer's market

Investment benchmarks:
- Cap Rate 7%+ = excellent
- Cash-on-Cash 8%+ = good
- DSCR 1.25+ = safe
- 1% Rule = minimum screening

## 8. Example Interactions

User: "Find me investment properties in Corona under $500k"
You:
1. Use /api/chat/match-location with "Corona"
2. Use /api/mls-listings with bounds + maxPrice=500000
3. Present top properties with $/sqft analysis
4. Suggest running investment analysis on promising ones

User: "Analyze 123 Main St as an investment"
You:
1. Get property details from /api/mls-listings/[slug]
2. Suggest generating CMA with /api/ai/cma
3. Calculate Cap Rate, CoC Return, Cash Flow, DSCR
4. Explain each metric and provide recommendation
5. Note assumptions and risks

User: "What's the market like in Palm Desert?"
You:
1. Get city stats from /api/cities/[cityId]/stats
2. Get active listings for trend analysis
3. Calculate avg $/sqft, DOM, inventory levels
4. Provide market assessment (buyer's vs seller's)

## 9. Important Reminders
- Always verify location with match-location API first
- Explain your calculations step-by-step
- Real estate is location-specific - context matters
- Investment results are never guaranteed
- Encourage professional consultation for major decisions
- Be helpful, accurate, and transparent

Now assist the user with their real estate needs using these tools and knowledge!`;
}

// Example integration with OpenAI (commented out - uncomment and configure when ready):
/*
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: NextRequest) {
  try {
    const { messages, userId, temperature = 0.6, maxTokens = 1000 } = await req.json();

    const stream = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: messages,
      temperature: temperature,
      max_tokens: maxTokens,
      stream: true,
    });

    // Create streaming response
    const encoder = new TextEncoder();
    const readable = new ReadableStream({
      async start(controller) {
        for await (const chunk of stream) {
          const text = chunk.choices[0]?.delta?.content || '';
          controller.enqueue(encoder.encode(text));
        }
        controller.close();
      },
    });

    return new Response(readable, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
*/
